#--------------------------------------------------------------------------
# set Working Directory
#--------------------------------------------------------------------------
setwd('/home/waseem/Documents/Self-Development/git_repos/waseem-self-development/Online Retail II UCI/')


#--------------------------------------------------------------------------
# Load libraries
#--------------------------------------------------------------------------
library(data.table)
library(ggplot2)
library(tidyverse)
library(lubridate)
library(gridExtra)
library(sqldf)
library(arules)
library(scales)


#--------------------------------------------------------------------------
# load dataset
#--------------------------------------------------------------------------

# we'll load the csv from our location
raw_dataset <- data.table(
	read.csv('/home/waseem/Documents/Self-Development/Online Retail II UCI/online_retail_II.csv', 
		stringsAsFactors = F)
)

#--------------------------------------------------------------------------
# clean dataset
#--------------------------------------------------------------------------

# create new DF, so we can revert back to this if we mess up
# saves us having to load the data into R again
# good practice for when we have large datasets which take time to load in
# or datasets which incur costs (such as loading in from BigQuery)
# we'll also change column names, personal preference as it makes it 
# quicker/easier for me to type out whilst i'm coding
dataset <- data.table(
	raw_dataset %>%
		rename(
			invoice_id = Invoice,
			stock_code = StockCode,
			description = Description,
			qty = Quantity,
			invoice_timestamp = InvoiceDate,
			price = Price,
			customer_id = Customer.ID,
			country = Country
		)
)

# lets check the structure of the dataset, to see if we need to change
# column types (e.g. string values into numeric etc)
str(dataset)
# the only columns which needs attention are invoice_timestamp and customer_id
# we need to change their column types
# we'll also feature engineer a product_revenue column
# this will be price x qty

dataset <- data.table(
		dataset %>%
			# first let's feature engineer a pure date column from invoice_timestamp
			# this just makes it easier later on to have them seperate
			# we'll then convert invoice_timestamp from string to timestamp
			# we'll convert customer_id into string
			mutate(
				invoice_date = ymd(substr(invoice_timestamp, 1, 10)),
				invoice_timestamp = ymd_hms(invoice_timestamp),
				customer_id = as.character(customer_id),
				product_revenue = price * qty
			)
)



# we'll run a summary over our dataset to understand it better
summary(dataset)
# look to see if we have any oddities/nulls in our dataset
sapply(dataset, function(x) sum(is.na(x)))
# Apart from customer_id, all our string columns don't have nulls
# we have 243007 nulls in the customer_id column (23% of all records)
# we also have negative values in qty and price columns
# our dataset date range is from 1st of Dec 2009 to 9th Dec 2011


# let's try and understand our nulls in customer_id
# we'll create a new dataframe for this, so we don't mess up our orginal dataset
customer_id_nulls <- data.table(
	dataset %>%
		# we'll create a new column as a flag it the row has a customer_id or is null
		mutate(has_customer_id = ifelse(is.na(customer_id) == F, 'yes', 'no'))
)
# we'll look to see how much revenue is generated by null customer_id's
customer_id_nulls_revenue <- data.table(
	customer_id_nulls %>%
		group_by(has_customer_id) %>%
		summarise(product_revenue = sum(product_revenue)) %>%
		ungroup() %>%
		mutate(percent = product_revenue/sum(product_revenue))
) %>% 
		ggplot(aes(x = has_customer_id, y = percent, fill = has_customer_id)) +
		geom_bar(stat = 'identity') +
		ggtitle('% of Total Revenue', 
						'From orders with customer_id vs without customer_id') +
		labs(x = 'Do we have a customer_id?', y = '% of Total Revenue') +
		# text for the conversion
		geom_text(aes(label = paste0(round(percent * 100), '%')), 
		          color = 'white', size = 4, fontface = 'bold',
		          position = position_stack(vjust = 0.5, reverse = FALSE)) +
		# gives the y axis the percentage scale
		scale_y_continuous(labels = scales::percent) +
		# we don't want a legend for the fill
		guides(fill = 'none')
# revenue from null customer_ids make up 14% of revenue
# we'll keep them in for revenue analysis, but we'll remove for any
# dedicated customer analysis


#--------------------------------------------------------------------------
# EDA visualisations
#--------------------------------------------------------------------------

# now that we're happy with our dataset, we'll conduct some EDA



# ----------------- revenue per country
revenue_per_country <- data.table(
	dataset %>%
		group_by(country) %>%
		summarise(revenue = sum(product_revenue)) %>%
		ungroup() %>%
		mutate(percent = revenue / sum(revenue)) %>%
		arrange(-percent)
) %>%
	ggplot(aes(x = reorder(country, revenue), y = revenue)) +
	geom_bar(stat = 'identity', fill = '#F8766D') +
	ggtitle('Revenue by Country',
					'The UK is by far the biggest market') +
	labs(x = 'Country', y = '£') +
	# text for the conversion
	geom_text(aes(label = ifelse(percent > 0.017,
									paste0(round(percent * 100), '%'),'')), 
	          color = 'black', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	# gives the y axis the percentage scale
	scale_y_continuous(labels = scales::comma) +
	# we don't want a legend for the fill
	guides(fill = 'none') +
	coord_flip() 
# UK is the biggest market, owning 85% of all revenue


# ----------------- revenue per country (minus UK)
# we'll look at percentage of revenue of countries minus UK
revenue_per_country_minus_UK <- data.table(
	dataset %>%
		filter(country != 'United Kingdom') %>%
		group_by(country) %>%
		summarise(revenue = sum(product_revenue)) %>%
		ungroup() %>%
		mutate(percent = revenue / sum(revenue)) %>%
		arrange(-percent)
) %>%
	ggplot(aes(x = reorder(country, revenue), y = revenue)) +
	geom_bar(stat = 'identity', fill = '#00BFC4') +
	ggtitle('Revenue by Country',
					'Without the UK') +
	labs(x = 'Country', y = '£') +
	# text for the conversion
	geom_text(aes(label = ifelse(percent > 0.01,
									paste0(round(percent * 100), '%'),'')), 
	          color = 'black', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	# gives the y axis the percentage scale
	scale_y_continuous(labels = scales::comma) +
	# we don't want a legend for the fill
	guides(fill = 'none') +
	coord_flip() 
# the next biggest markets are EIRE, Netherlands, Germany and France

viz_1 <- grid.arrange(revenue_per_country, revenue_per_country_minus_UK, nrow = 1)
ggsave(file = '/home/waseem/Documents/Self-Development/Online Retail II UCI/viz_1.png', 
				viz_1, width = 9.5, height = 8.5, units = 'in')









# We'll concentrate our analysis on these core 5 markets
top_5_markets <- c('United Kingdom', 'EIRE', 'Netherlands', 'Germany', 'France')


# ----------------- AOV by Top 5 Markets
# all orders which are returns (negative revenue)
# start with A, 'C' in their invoice_id
# so we'll remove these
top5_aov <- data.table(
	dataset %>%
		filter(country %in% top_5_markets) %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		group_by(country) %>%
		summarise(revenue = sum(product_revenue),
							orders = n_distinct(invoice_id)) %>%
		ungroup() %>%
		mutate(aov = revenue / orders)
) %>%
	ggplot(aes(x = reorder(country, desc(aov)), y = aov, fill = country)) +
	geom_bar(stat = 'identity') +
	ggtitle('AOV by Country',
					'Top 5 Markets, no outliers removed') +
	labs(x = 'Country', y = 'AOV (£)') +
	# text for the conversion
	geom_text(aes(label = paste0('£', round(aov))), 
	          color = 'white', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	# gives the y axis the percentage scale
	scale_y_continuous(labels = scales::comma) +
	# we don't want a legend for the fill
	guides(fill = 'none')
# Netherlands looks to have the highest AOV by far, with UK having the lowest
# though outliers may be causing this


# ----------------- Order Values Top 5 Markets Boxplot
top5_ov_boxplot <- data.table(
	dataset %>%
		filter(country %in% top_5_markets) %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		group_by(country, invoice_id) %>%
		summarise(order_value = sum(product_revenue))
) %>%
	ggplot(aes(x = country, y = order_value, fill = country)) +
	geom_boxplot() +
	ggtitle('Order values by Country',
					'Top 5 Markets, with outliers removed') +
	labs(x = 'Country', y = 'Order Value (£)') +
	# we don't want a legend for the fill
	guides(fill = 'none') +
	scale_y_continuous(breaks = seq(0, 1800, 100), limits = c(0, 1800))


# ----------------- Order Values Top 5 Markets Histogram
top5_ov_hist <- data.table(
	dataset %>%
		filter(country %in% top_5_markets) %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		group_by(country, invoice_id) %>%
		summarise(order_value = sum(product_revenue))
) %>%
	ggplot(aes(x = order_value, fill = country)) +
	geom_histogram(binwidth = 50, colour = 'black') + 
	ggtitle('Order values by Country',
					'Top 5 Markets, in £50 bins') +
	labs(x = 'Order Value (£)', y = 'No. of Orders') + 
	guides(fill = 'none') +
	# scale_x_continuous(breaks = seq(0, 3000, 250), lim = c(-50, 3000)) +
	xlim(-50, 3000) +
	facet_wrap(country ~ ., scales = 'free') +
	scale_y_continuous(labels = scales::comma)


viz_2 <- grid.arrange(grid.arrange(top5_aov, top5_ov_boxplot, nrow = 1),
											top5_ov_hist)
ggsave(file = '/home/waseem/Documents/Self-Development/Online Retail II UCI/viz_2.png', 
				viz_2, width = 9.5, height = 8.5, units = 'in')









# ----------------- Total customers by Country
top5_customers_nums <- data.table(
	dataset %>%
		filter(country %in% top_5_markets) %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		# remove NULL customer_ids
		filter(is.na(customer_id) == F) %>%
		group_by(country) %>%
		summarise(customers = n_distinct(customer_id))
) %>%
	ggplot(aes(x = reorder(country, customers), y = customers, fill = country)) +
	geom_bar(stat = 'identity') +
	ggtitle('Number of Customers',
					'Top 5 Markets') +
	labs(x = 'Country', y = 'Number of Customers') +
	# text for the conversion
	geom_text(aes(label = customers), 
	          color = 'black', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	# gives the y axis the percentage scale
	scale_y_continuous(labels = scales::comma) +
	# we don't want a legend for the fill
	guides(fill = 'none') +
	coord_flip()
# amazingly Eire only has 5 customers


# ----------------- Customer Order Value by Top 5 Markets
# all orders which are returns (negative revenue)
# start with A, 'C' in their invoice_id
# so we'll remove these
top5_cv <- data.table(
	dataset %>%
		filter(country %in% top_5_markets) %>%
		group_by(country) %>%
		summarise(revenue = sum(product_revenue),
							customers = n_distinct(customer_id)) %>%
		ungroup() %>%
		mutate(cv = revenue / customers)
) %>%
	ggplot(aes(x = reorder(country, cv), y = cv, fill = country)) +
	geom_bar(stat = 'identity') +
	ggtitle('Avg. Customer Value by Country',
					'Top 5 Markets, no outliers removed') +
	labs(x = 'Country', y = 'Avg. Customer Value (£)') +
	# text for the conversion
	geom_text(aes(label = paste0('£', format(round(cv), big.mark = ','))), 
	          color = 'black', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	# gives the y axis the percentage scale
	scale_y_continuous(labels = scales::comma) +
	# we don't want a legend for the fill
	guides(fill = 'none') +
	coord_flip()
# Avg. customer value for EIRE is massive


# ----------------- Number of Orders by Customers (Top 5 Markets)
# all orders which are returns (negative revenue)
# start with A, 'C' in their invoice_id
# so we'll remove these
top5_orders_by_customers <- data.table(
	dataset %>%
		filter(country %in% top_5_markets) %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		group_by(country) %>%
		summarise(orders = n_distinct(invoice_id),
							customers = n_distinct(customer_id)) %>%
		ungroup() %>%
		mutate(orders_per_customer = round(orders / customers, 2))
) %>%
	ggplot(aes(x = reorder(country, orders_per_customer), 
							y = orders_per_customer, fill = country)) +
	geom_bar(stat = 'identity') +
	ggtitle('Number of Orders Per Customer',
					'Top 5 Markets, no outliers removed') +
	labs(x = 'Country', y = 'Avg. Number of Orders Per Customer') +
	# text for the conversion
	geom_text(aes(label = orders_per_customer), 
	          color = 'black', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	# gives the y axis the percentage scale
	scale_y_continuous(labels = scales::comma) +
	# we don't want a legend for the fill
	guides(fill = 'none') +
	coord_flip()



# ----------------- Top 5 customers for the Top 5 Markets
top5_top_customers <- data.table(
	dataset %>%
		filter(country %in% top_5_markets) %>%
			# remove NULL customer_ids
		filter(is.na(customer_id) == F) %>%
		group_by(country, customer_id) %>%
		summarise(revenue = sum(product_revenue)) %>%
		ungroup() %>%
		group_by(country) %>%
		mutate(ranked = row_number(desc(revenue))) %>%
		filter(ranked <= 5)
) %>%
	ggplot(aes(x = reorder(customer_id, desc(ranked)), 
							y = revenue, fill = country)) +
	geom_bar(stat = 'identity') +
	ggtitle('Top 5 Customers by Customer Value',
					'Top 5 Markets') +
	labs(x = 'Customer ID', y = 'Customer Value (£)') +
	# text for the conversion
	geom_text(aes(label = paste0('£', format(round(revenue), big.mark = ','))), 
	          color = 'black', size = 4,
	          position = position_stack(vjust = 0.8, reverse = FALSE)) +
	# gives the y axis the percentage scale
	scale_y_continuous(labels = scales::comma) +
	# we don't want a legend for the fill
	guides(fill = 'none') +
	coord_flip() +
	facet_wrap(. ~ country, scales = 'free')


viz_3 <- grid.arrange(grid.arrange(top5_customers_nums, top5_cv, 
												top5_orders_by_customers, nrow = 1),
											top5_top_customers)
ggsave(file = '/home/waseem/Documents/Self-Development/Online Retail II UCI/viz_3.png', 
				viz_3, width = 9.5, height = 8.5, units = 'in')




# we'll now look into products


# Best selling products
best_sellers <- data.table(
	dataset %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		group_by(stock_code, description) %>%
		summarise(orders = n_distinct(invoice_id),
							revenue = sum(product_revenue)) %>%
		arrange(-revenue) %>%
		# we'll remove random stock_codes e.g manual or postage
		filter(!(stock_code %in% c('M', 'DOT', 'POST')))
)


best_sellers_revenue <- data.table(
	best_sellers %>%
	mutate(ranked = row_number(desc(revenue))) %>%
	filter(ranked <= 10)
) %>%
	ggplot(aes(x = reorder(description, desc(ranked)), 
							y = revenue)) +
	geom_bar(stat = 'identity', fill = '#F8766D') +
	ggtitle('Best Sellers',
					'By Revenue') +
	labs(x = 'Product', y = 'Revenue (£)') +
	# text for the conversion
	geom_text(aes(label = paste0('£', format(round(revenue), big.mark = ','))), 
	          color = 'white', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	scale_y_continuous(labels = scales::comma) +
	coord_flip() +
	# this will wrap the long x labels
  scale_x_discrete(labels = function(x) str_wrap(x, width = 20))


best_sellers_order <- data.table(
	best_sellers %>%
	mutate(ranked = row_number(desc(orders))) %>%
	filter(ranked <= 10)
) %>%
	ggplot(aes(x = reorder(description, desc(ranked)), 
							y = orders)) +
	geom_bar(stat = 'identity', fill = '#00BFC4') +
	ggtitle('Best Sellers',
					'By Orders') +
	labs(x = 'Product', y = 'Orders') +
	# text for the conversion
	geom_text(aes(label = format(round(orders), big.mark = ',')), 
	          color = 'white', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	scale_y_continuous(labels = scales::comma) +
	coord_flip() +
	# this will wrap the long x labels
  scale_x_discrete(labels = function(x) str_wrap(x, width = 20))


# we'll now look at the most returned products
returned_products <- data.table(
		dataset %>%
		# keep returns
		filter((substr(invoice_id, 1, 1) %in% c('C'))) %>%
		group_by(stock_code, description) %>%
		summarise(orders = n_distinct(invoice_id),
							revenue = sum(product_revenue)) %>%
		arrange(-orders)  %>%
		ungroup() %>%
		# we'll remove the following products
		filter(!(stock_code %in% c('M', 'D', 'POST'))) %>%
		mutate(ranked = row_number(desc(orders))) %>%
		filter(ranked <= 10)
) %>%
	ggplot(aes(x = reorder(description, desc(ranked)), 
							y = orders)) +
	geom_bar(stat = 'identity', fill = '#C77CFF') +
	ggtitle('Most Returned Products',
					'By Orders') +
	labs(x = 'Product', y = 'Orders') +
	# text for the conversion
	geom_text(aes(label = format(round(orders), big.mark = ',')), 
	          color = 'white', size = 4, fontface = 'bold',
	          position = position_stack(vjust = 0.5, reverse = FALSE)) +
	scale_y_continuous(labels = scales::comma) +
	coord_flip() +
	# this will wrap the long x labels
  scale_x_discrete(labels = function(x) str_wrap(x, width = 20))


# we'll look at products per order (by Top 5 Markets)
products_per_order <- data.table(
	dataset %>%
		filter(country %in% top_5_markets) %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		# we'll remove random stock_codes e.g manual or postage
		filter(!(stock_code %in% c('M', 'DOT', 'POST'))) %>%
		group_by(country, invoice_id) %>%
		summarise(products_in_order = n_distinct(stock_code))
)  %>%
	ggplot(aes(x = country, y = products_in_order, fill = country)) +
	geom_boxplot() +
	ggtitle('Products Per Order',
					'Top 5 Markets, with outliers removed') +
	labs(x = 'Country', y = 'Number of Unique Products in Order') +
	# we don't want a legend for the fill
	guides(fill = 'none') +
	scale_y_continuous(breaks = seq(0, 84, 5), limits = c(0, 84))

viz_4 <- grid.arrange(grid.arrange(best_sellers_revenue, best_sellers_order, nrow = 1),
											grid.arrange(returned_products, products_per_order, nrow = 1))
ggsave(file = '/home/waseem/Documents/Self-Development/Online Retail II UCI/viz_4.png', 
				viz_4, width = 9.5, height = 8.5, units = 'in')




#--------------------------------------------------------------------------
# Apriori Algorithm
#--------------------------------------------------------------------------

# The below algorithm will help us uncover items frequently bought together

# we'll prepare the dataset for the apriori algorithm
apriori <- data.table(
	dataset %>%
		# we'll only look at United Kingdom
		filter(country == 'United Kingdom') %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		# we'll remove random stock_codes e.g manual or postage
		filter(!(stock_code %in% c('M', 'DOT', 'POST'))) %>%
		group_by(invoice_id) %>%
		# this will create a new column called products
		# which will store all products bought in an order (invoice_id)
		# each product will be seperated by '|'
		mutate(products = paste0(description, collapse = "|")) %>%
		ungroup() %>%
		select(invoice_id, products) %>%
		unique() %>%
		# this just counts how many products we have in our products column
		# it's a helper column for when we want to seperate each individual
		# products into seperate columns
		mutate(sep_count = (str_count(products, "\\|")+1))
)
# this will seperate each individual product into seperate columns
apriori <- data.table(
	apriori %>% 
		separate(products, into = paste0('product',1:max(apriori$sep_count)), 
							sep = '\\|')
)
# we only want the products in our final dataframe
apriori <- data.table(
	apriori %>%
		select(-sep_count, -invoice_id)
)
# this will write our apriori dataset into a .csv file
write.table(apriori, 
				'/home/waseem/Documents/Self-Development/Online Retail II UCI/apriori.csv', 
				row.names = F, col.names = F, na = '', sep = ',')

# this will bring our apriori data into R in the format needed for the apriori algorithm
apriori <- read.transactions('/home/waseem/Documents/Self-Development/Online Retail II UCI/apriori.csv', 
												rm.duplicates = T, sep = ',')

# Training Apriori on the dataset
rules <- apriori(data = apriori, 
                 parameter = list(supp = 0.001, conf = 0.8, maxlen = 10))

# this gives a summary of our apriori algorithm
summary(rules)

# Visualising the results
inspect(sort(rules, by = 'support')[1:20])

# this saves our apriori algorithm results in a .csv file
write(rules, 
			file = '/home/waseem/Documents/Self-Development/Online Retail II UCI/apriori_rules.csv', 
			sep = ',', row.names = F)




#--------------------------------------------------------------------------
# Customer Segmentation using RFM & K-Means Clustering
#--------------------------------------------------------------------------

# We will create customer segments based on their value & purchasing behaviour
# Using RFM (Recency, Frequency & Monetary), we'll segment them using K-Means Clustering
# Recency: Time since customer's last transaction (based on max date in the dataset)
# Frequency: Total number of transactions
# Monetary: Total money spend by the customer

# over here we'll find the invoice_date
max_invoice_date <- data.table(
	dataset %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		# we'll remove random stock_codes e.g manual or postage
		filter(!(stock_code %in% c('M', 'DOT', 'POST'))) %>%
		# remove NULL customer_ids
		filter(is.na(customer_id) == F) %>%
		select(invoice_date)
)
max_invoice_date <- max(max_invoice_date$invoice_date)

segment <- data.table(
	dataset %>%
		# remove returns
		filter(!(substr(invoice_id, 1, 1) %in% c('C', 'A'))) %>%
		# we'll remove random stock_codes e.g manual or postage
		filter(!(stock_code %in% c('M', 'DOT', 'POST'))) %>%
		# remove NULL customer_ids
		filter(is.na(customer_id) == F) %>%
		group_by(customer_id) %>%
		mutate(
			recency = as.numeric(max_invoice_date - max(invoice_date)),
			frequency = n_distinct(invoice_id),
			monetary = sum(product_revenue)
		) %>%
		ungroup() %>%
		select(customer_id, recency, frequency, monetary) %>%
		unique() 
		# %>%
		# mutate(
		# 	recency = rescale(recency),
		# 	frequency = rescale(frequency),
		# 	monetary = rescale(monetary)
		# )
)
# we'll scale the columns, so that they are all normalised
segment_scaled = as.matrix(scale(select(segment, -customer_id)))


# Elbow Method for finding the optimal number of clusters
set.seed(0)
# Compute and plot wss for k = 2 to k = 15.
k.max <- 10
wss <- sapply(1:k.max, 
              function(k){kmeans(segment_scaled, k, nstart = 50, iter.max = 15 )$tot.withinss})
plot(1:k.max, wss,
     type = 'b', pch  =  19, frame  =  FALSE, 
     xlab = 'Number of clusters K',
     ylab = 'Total within-clusters sum of squares')
# we will build with 4 clusters

#Let us apply kmeans for k=4 clusters 
kmm <- kmeans(segment_scaled, 4, nstart = 50, iter.max = 15) 

# add the clusters info in our dataframe
segment$cluster <- kmm$cluster


# this is a summary of our K-means
segment_summary <- data.table(
	segment %>% 
		group_by(cluster) %>% 
		summarise(
			# this will show us the number of customers in each cluster
			customers = n_distinct(customer_id),
			recency_mean = round(mean(recency)),
			frequency_mean = round(mean(frequency)),
			monetary_mean = round(mean(monetary)),
		)
)
